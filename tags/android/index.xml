<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>android on</title><link>https://yazilim.aykutasil.com/tags/android/</link><description>Recent content in android on</description><generator>Hugo -- gohugo.io</generator><language>en-US</language><lastBuildDate>Tue, 02 Nov 2021 20:17:23 +0300</lastBuildDate><atom:link href="https://yazilim.aykutasil.com/tags/android/index.xml" rel="self" type="application/rss+xml"/><item><title>Android SMS User Consent API Kullanımı</title><link>https://yazilim.aykutasil.com/android_sms_user_consent_api/</link><pubDate>Tue, 02 Nov 2021 20:17:23 +0300</pubDate><guid>https://yazilim.aykutasil.com/android_sms_user_consent_api/</guid><description>Problem? Android işletim sisteminin ilk versiyonlarında SMS&amp;lsquo;lere erişim oldukça kolaydı. Fakat şimdi sadece özel izne sahip uygulamalar bu izne sahip olabiliyor. Google&amp;rsquo;a bir form doldurarak ve neden SMS okuma özelliğine kesin olarak ihtiyacınız olduğunu anlatarak bu izni talep ediyorsunuz. Peki bizim amacımız tek seferlik bir SMS okumak ise yine bu süreçten geçmeli miyiz? Hayır!
Google tek seferlik SMS okuması yapabilmek için çeşitli API&amp;rsquo;ler çıkardı. Bu API&amp;rsquo;lere sayfanın en altında bulunan Kaynaklar bölümünden erişebilirsiniz.</description></item><item><title>Android Fastlane Kurulumu</title><link>https://yazilim.aykutasil.com/fastlane-setup/</link><pubDate>Wed, 04 Nov 2020 13:14:18 +0300</pubDate><guid>https://yazilim.aykutasil.com/fastlane-setup/</guid><description>Fastlane, mobil ile ilgili neredeyse tüm süreçleri (build,test,deploy vs.) otomatize etmeye yarayan bir araçtır. Fastlane kullanarak hangi CI/CD platformunu kullanıyor olursanız olun uygulama süreçleriniz tekil hale getirebilirsiniz.
Kurulum brew install fastlane Fastlane aracının kurulumunu tamamladıktan sonra, ilk olarak projenizin root klasörüne gelip fastlane init komutunu çalıştırmalısınız.
Komut satırında Package Name istenildiğinde uygulamamızın package name&amp;lsquo;ini (com.example.myapplication) giriyoruz. Diğer adımları şimdilik es geçebilirsiniz. Proje yapılandırması tamamlandığında app klasörü ile aynı seviyede fastline isimli bir klasör oluşacak.</description></item><item><title>Android Fastlane Screengrab Kurulumu</title><link>https://yazilim.aykutasil.com/fastlane-screengrab/</link><pubDate>Wed, 04 Nov 2020 13:14:18 +0300</pubDate><guid>https://yazilim.aykutasil.com/fastlane-screengrab/</guid><description>Fastlane kurulumunu henüz tamamlamadıysanız sizi buraya alalım.
Screengrab Mobil ekran görüntüsü alımını otomatize eden bu aracın kullanımı için öncelikle aşağıdaki komut ile ilgili aracı yüklüyoruz. sudo gem install screengrab Daha sonra AndroidManifest.xml dosyasına aşağıdaki bloğu eklemeliyiz. &amp;lt;!-- Allows unlocking your device and activating its screen so UI tests can succeed --&amp;gt; &amp;lt;uses-permission android:name=&amp;#34;android.permission.DISABLE_KEYGUARD&amp;#34; /&amp;gt; &amp;lt;uses-permission android:name=&amp;#34;android.permission.WAKE_LOCK&amp;#34; /&amp;gt; &amp;lt;!-- Allows for storing and retrieving screenshots --&amp;gt; &amp;lt;uses-permission android:name=&amp;#34;android.</description></item><item><title>Android applicationId vs package name</title><link>https://yazilim.aykutasil.com/android-applicationid-vs-packagename/</link><pubDate>Sun, 21 Jun 2020 19:36:41 +0300</pubDate><guid>https://yazilim.aykutasil.com/android-applicationid-vs-packagename/</guid><description>Android projesi oluşturduğunuzda aşağıdaki gibi AndroidManifest.xml ve build.gradle dosyaları oluşur. AndroidManifest.xml içerisinde package tagı ve build.gradle içerisinde applicationId niteliği bulunur.
Peki bu ikisi arasındaki fark nedir?
package=&amp;quot;com.example.myapp&amp;rdquo; ile belirttiğimiz kısım aslında projemizin klasör yapısını ifade eder. Yani com &amp;gt; example &amp;gt; myapp şeklinde bir tree yapısı vardır. Ve biz proje dosyalarımızı bu dizin altında oluşturmaya başlarız. Örneğin MainActivity dosyası oluşturduğumuzda aslında bu dosyanın yolu com.example.myapp.MainActivity olur. Projemiz derlenme sırasında package değerine bakar ve dosyaları bu adrese göre bulur.</description></item><item><title>Android Background Location</title><link>https://yazilim.aykutasil.com/android-background-location/</link><pubDate>Fri, 17 Jan 2020 18:13:00 +0300</pubDate><guid>https://yazilim.aykutasil.com/android-background-location/</guid><description>Android 10 ile birlikte gelen değişiklerden biri de Location dinleme ile alakalıdır. Uygulamamız arka plandayken (background) ve ön plandayken (foreground) konum dinleme şekilleri farklılık göstermektedir. Uygulamımız bize görünür vaziyette ise yani foreground&amp;lsquo;da ise her hangi bir değişiklik yapmamıza gerek yoktur. Fakat Home tuşuna basarak veya başka bir uygulama açarak uygulamamızı arka plana atıyorsak ve bu sırada konum dinlemesinin devam etmesini istiyorsak bazı düzenlemeler yapmamız gerekmektedir.
İki şekilde background konum dinlemesi yapılabilir.</description></item><item><title>Android Debugging With Local Web Server</title><link>https://yazilim.aykutasil.com/android-debugging-local-server/</link><pubDate>Sat, 03 Aug 2019 03:14:28 +0300</pubDate><guid>https://yazilim.aykutasil.com/android-debugging-local-server/</guid><description>Fiziksel Android cihazımızla localimizde çalışan web server&amp;rsquo;a erişmek, development aşamasında eminim ihtiyaç duyduğunuz veya duyacağınız gereksinimlerden biridir. Bununla beraber local makinenizde bulunan VM üzerinde koşan web server&amp;rsquo;a erişmek.. Ah harika..
Canlı bir örnek verirsem sanıyorum daha iyi olacak.
Geliştirme yaptığınız makinenizinde MacOS işletim sistemi var. Bununla beraber çeşitli ihtiyaçlarınızdan ötürü windows kurmanız gerekti ve Virtual Machine kurarak içine windows yüklediniz. Windows üzerinde Visual Studio ile bir WebApi ayağa kaldırdınız ve bu api&amp;lsquo;ye fiziksel Android cihazınızdan erişmek istiyorsunuz.</description></item><item><title>ADB Komutu ile Cihaz IP'sini Öğren</title><link>https://yazilim.aykutasil.com/deviceip-with-adb/</link><pubDate>Sat, 20 Jul 2019 01:04:53 +0300</pubDate><guid>https://yazilim.aykutasil.com/deviceip-with-adb/</guid><description>Aşağıdaki komutu çalıştırarak android cihaz ip&amp;rsquo;sini öğrenebilirsiniz.
&amp;gt; adb shell ip -f inet addr show wlan0</description></item><item><title>Android File System</title><link>https://yazilim.aykutasil.com/android-filesystem/</link><pubDate>Thu, 27 Jun 2019 14:00:59 +0300</pubDate><guid>https://yazilim.aykutasil.com/android-filesystem/</guid><description>Internal Storage vs External Storage Internal Storage Her zaman erişilebilir. Sadece uygulamanın kendisi tarafından erişebilir. Buraya kaydedilen dosyalar başka bir uygulama tarafından görünmez. USB ile bilgisayara bağlanıldığında bu dosyalara erişim sağlanamaz. Uygulama silindiğinde internal storage temizlenir. External Storage Her zaman erişilebilir durumda olmayabilir. External storage cihaza dahili olarak bulunabileceği gibi USB cihazı olarak sonradan takılmış bir cihaz da olabilir. Bu nedenle erişebilir olup olmadığı kontrol edilmelidir (getExternalStorageState()). External Storage&amp;rsquo;a kayıt edilen dosyalar başka uygulamalar tarafından okunabilir ve görülebilir durumda olabilir.</description></item><item><title>Android DataBinding</title><link>https://yazilim.aykutasil.com/android-databinding/</link><pubDate>Mon, 25 Feb 2019 00:00:27 +0300</pubDate><guid>https://yazilim.aykutasil.com/android-databinding/</guid><description>Android DataBinding Android dünyasında temiz kod(Clean Code) günümüzde çokça konuşulan konular arasında yer almakta ve neden temiz kod yazmalıyız ile alakalı bir çok makale yazılmaktadır.
Temiz kod yazmak için MVP, MVVM vs. kod tasarım mimarilerinden birini seçerek yazılan kodların ve etkileşimlerinin birbirinden ayrımını sağlamaktayız. Bu kod tasarım kalıpları ile beraber bize çok faydası olacak bir mimari daha bulunmakta: DataBinding
DataBinding Uygulamanın arayüzünü tasarlamak için kullandığımız layout dosyamızın içerisine Uygulamamızın arayüzünü oluşturmak için kullandığımız layout xml dosyalarına gerekli datayı doğrudan entegre ederek, arayüz değişikliği ile ilgili tüm akışların harici müdahaleye gerek kalmadan otomatik olarak gerçekleşmesini sağlayabiliriz.</description></item><item><title>Android Service</title><link>https://yazilim.aykutasil.com/android-service/</link><pubDate>Thu, 14 Feb 2019 13:10:18 +0300</pubDate><guid>https://yazilim.aykutasil.com/android-service/</guid><description>Android&amp;rsquo;in temel bileşenlerinden biri olan Service&amp;lsquo;ler kısaca UI(arayüz) olmayan Activity&amp;lsquo;lere benzetebiliriz. Tabi ki kendine göre ek özellikleri bulunmaktadır. Service tanımlaması AndroidManifest.xml içerisinde tanımlı olmalıdır. Aksi takdirde çalışmaz. &amp;lt;service&amp;gt; elementinin alabileceği özellikler aşağıdaki gibidir.
Niçin kullanılır? Temel olarak ifade etmek gerekirse Service&amp;lsquo;lerin kullanım amacı uzun süren ve arka planda(background) çalışan taskler oluşturmaktır. Bununla birlikte diğer uygulamalar tarafından çağırılabilen iletişim imkanı sağlar.
Service tanımlanması &amp;lt;service android:description=&amp;#34;string resource&amp;#34; android:directBootAware=[&amp;#34;true&amp;#34; | &amp;#34;false&amp;#34;] android:enabled=[&amp;#34;true&amp;#34; | &amp;#34;false&amp;#34;] android:exported=[&amp;#34;true&amp;#34; | &amp;#34;false&amp;#34;] android:icon=&amp;#34;drawable resource&amp;#34; android:isolatedProcess=[&amp;#34;true&amp;#34; | &amp;#34;false&amp;#34;] android:label=&amp;#34;string resource&amp;#34; android:name=&amp;#34;string&amp;#34; android:permission=&amp;#34;string&amp;#34; android:process=&amp;#34;string&amp;#34; &amp;gt; .</description></item><item><title>Android Kotlin Test - Final Type Problem</title><link>https://yazilim.aykutasil.com/android-kotlin-test-final-type-problem/</link><pubDate>Tue, 29 Jan 2019 15:38:29 +0300</pubDate><guid>https://yazilim.aykutasil.com/android-kotlin-test-final-type-problem/</guid><description>Sorun Kotlin dili ile geliştirilen Android projelerinin test yazımı sırasında sınıfların veya metodların mocklanması, Java ile geliştirilen projelere göre bazı farklılıklar göstermektedir. Bu farklılığın sebeplerinden biri Kotlin ile oluşturulan sınıf veya metodların default olarak final olarak işaretlenmiş olmasıdır. Ve final tipindeki sınıfların mocklanması bazı sorunlar çıkarmaktadır.
Çözüm Final tipindeki sınıfların veya metodların mocklama işlemi sırasında çıkan sorunu çözmenin birkaç farklı yöntemi vardır.
Çözüm 1 (open ClassName) Test edeceğimiz sınıf ve metodun başına open ifadesini ekleyerek extend edilebilir hale getirmek.</description></item><item><title>Android CircleCI Configuration</title><link>https://yazilim.aykutasil.com/android-circleci/</link><pubDate>Sat, 01 Dec 2018 14:20:45 +0300</pubDate><guid>https://yazilim.aykutasil.com/android-circleci/</guid><description>CircleCI Android Yapılandırması .circleci/config.yml version: 2 jobs: build: working_directory: ~/code docker: - image: circleci/android:api-28-alpha environment: JVM_OPTS: -Xmx3200m steps: - checkout - run: name: Initialize Keystore File command: echo $KEYSTORE_BASE64 | base64 --decode &amp;gt; app/aykutasilkeystore - run: name: Initialize Fabric Properties command: | echo &amp;#34;apiKey=$FABRIC_API_KEY&amp;#34; &amp;gt;&amp;gt; app/fabric.properties echo &amp;#34;apiSecret=$FABRIC_API_SECRET&amp;#34; &amp;gt;&amp;gt; app/fabric.properties cat app/fabric.properties - run: name: Initialize Keystore File command: | echo &amp;#34;signingKeyAlias=$KEYSTORE_KEY_ALIAS&amp;#34; &amp;gt;&amp;gt; keystore.properties echo &amp;#34;signingKeyAliasPassword=$KEYSTORE_KEY_ALIAS_PASSWORD&amp;#34; &amp;gt;&amp;gt; keystore.properties echo &amp;#34;signingStoreFile=$KEYSTORE_STORE_FILE&amp;#34; &amp;gt;&amp;gt; keystore.</description></item><item><title>Android Dagger</title><link>https://yazilim.aykutasil.com/android-dagger/</link><pubDate>Fri, 12 Oct 2018 11:48:08 +0300</pubDate><guid>https://yazilim.aykutasil.com/android-dagger/</guid><description>@BindsInstance Bağımlılıklarınızı oluşturma esnasında belirtmeniz gereken bir değişkenininiz var ve bu değişkeni diğer module leriniz içerisinde kullanıcaksınız. Aşağıdaki gibi @BindsInstance kullanarak bu bağımlılığınızı dependency graph içerisine ekleyerek diğer modüller içerisinde kullanımını sağlayabilirsiniz.
@Component(modules = AppModule.class) interface AppComponent { App app(); @Component.Builder interface Builder { @BindsInstance Builder apiUrl(@ApiUrl String apiUrl); AppComponent build(); } } Component build edilirken apiUrl değeri bind edilir.
App app = DaggerAppComponent .builder() .apiUrl(&amp;#34;http://....&amp;#34;) .build()</description></item><item><title>Android Test</title><link>https://yazilim.aykutasil.com/android-test/</link><pubDate>Tue, 18 Sep 2018 11:51:07 +0300</pubDate><guid>https://yazilim.aykutasil.com/android-test/</guid><description>Not: Bu yazıyı hazırlarken ben de öğrenme sürecinde olucam. Araştırdığım ve öğrendiğim tüm teknik bilgileri ve yöntemleri, best-practice leri gelişi güzel(karmakarışık değil) bir şekilde yazıcam. Sonrasında zaman bulduğum vakit bir düzenleme yapıcam.
Unit Test ve Instrumentation Test Unit Test Unit Test: Android framework ünden bağımsız olan sınıfları/metodları test etmek için kullanılır. Robolectric ve JUnit popüler unit test araçlarıdır.
If you run local unit tests, a special version of the android.</description></item><item><title>Android Backstack Navigate</title><link>https://yazilim.aykutasil.com/android-backstack-navigate/</link><pubDate>Fri, 04 May 2018 17:38:15 +0300</pubDate><guid>https://yazilim.aykutasil.com/android-backstack-navigate/</guid><description>Android Navigate Örnek Senaryo Kullanıcıya bir ürün ile ilgili notification yolladınız. Kullanıcı bu notification a tıkladığında direk olarak Ürün Detay sayfasına yönlendiriliyor. Kullanıcı sayfada işi bittiğinde geri tuşuna basıyor ve siz bu durumda kullanıcıyı uygulamanın Anasayfasına yönlendirmek istiyorsunuz. Ek bir geliştirme yapmadığınız takdirde bu senaryo için geri tuşuna basıldığında uygulama kapanır. Çünkü geri gidecek ekranı yoktur. Direk olarak Detay sayfası açılmıştır.
Çözüm İlk olarak yapmamız gereken Manifest.xml dosyasında DetailActivity tanımlamasını yaptığımız yerde parentActivityName i belirtmek.</description></item><item><title>Android Architecture Components</title><link>https://yazilim.aykutasil.com/android-architecture-components/</link><pubDate>Sun, 27 Aug 2017 00:00:00 +0000</pubDate><guid>https://yazilim.aykutasil.com/android-architecture-components/</guid><description>Android Architecture Components Öncelikle şu linkleri verelim:
https://developer.android.com/topic/libraries/architecture/index.html Lifecycle LiveData ViewModel LifeCycle Daha önce Android uygulaması geliştirenler çok iyi bilirler ki bir activity veya fragment&amp;rsquo;ın yaşam döngüsünü yönetmek sıkıntılı bir süreçtir. Activity&amp;rsquo;nin arka planda mı yoksa görünür vaziyette mi oluşuna göre düzenlenen akışlar çoğu zaman yoğun dikkat gerektiren süreçlerdir. Yukarıda ki Lifecycle linkine tıklarsanınz çok güzel bir örnek ile durumu açıklamışlar.
Oluşturduğumuz nesneler eğer activity&amp;rsquo;nin yaşam döngüsüne bağlı ise bunu yönetmek için activity&amp;rsquo;mizin genelde onCreate ve onStop metodları içerisinde bu nesnelere ait fonksiyonları çağırıyorduk.</description></item><item><title>Kotlin @JvmOverloads</title><link>https://yazilim.aykutasil.com/kotlin-jvmoverloads/</link><pubDate>Sun, 09 Jul 2017 00:00:00 +0300</pubDate><guid>https://yazilim.aykutasil.com/kotlin-jvmoverloads/</guid><description>Kotlin @JvmOverloads Kotlin ile uygulama geliştirmeyi teşvik eden en büyük etkenlerden biri şüphesiz Java dili uyumlu yapısıdır. Her iki tarafdan da birbirlerine referanslar verilebilir.
Kotlin dilinin Java&amp;rsquo;dan ayıran özelliklerinden biri Java compiler ından daha zeki olmasıdır. Nitekim java dili yaşlanıyor :). Kotlin ile oluşturulan bazı yapıların Java tarafına uyumlu hale getirilmesi için bazen ufak düzenlemelere gerek duyulabiliyor. Bu düzenlemelerden bir tanesi de @JvmOverloads annotation kullanımı.
fun ViewGroup.inflate(resId: Int, attachToRoot: Boolean = false): View { return LayoutInflater.</description></item><item><title>Kotlin Sealed Class</title><link>https://yazilim.aykutasil.com/kotlin-sealed-class/</link><pubDate>Sat, 01 Jul 2017 00:00:00 +0300</pubDate><guid>https://yazilim.aykutasil.com/kotlin-sealed-class/</guid><description>Kotlin Sealed Class Enum yapısına benzer bir yapıya sahiptir. Ve benzer görevler için kullanılır. Aradaki fark enum lar sabit değer ifade etmek için kullanılırken sealed yapısı normal sınıf gibi fakat enum mantığıyla kullanılır. Yani belli bir duruma ait fonksiyonları bir arada tutmak ve when() gibi fonksiyonlar ile birlikte kullanımını sağlamak için kullanılır.
// Sealed class enum yapısına benzer // Bir durum için belli başlı akışları bir arada tutmamızı sağlar ve bu akışların yönetimini kolaylaştırır.</description></item><item><title>Kotlin when kullanımı</title><link>https://yazilim.aykutasil.com/kotlin-when/</link><pubDate>Tue, 06 Jun 2017 04:42:56 +0300</pubDate><guid>https://yazilim.aykutasil.com/kotlin-when/</guid><description>Kotlin&amp;rsquo;de when operatörü işimizi oldukça kolaylaştıran operatörlerden biridir.
if- else if yapısı yerine kullanılabileceği gibi bazı yardımcı operatörler ile birçok marifet kazanabilir.
val i = 10 when { i &amp;lt; 7 -&amp;gt; println(&amp;#34;first block&amp;#34;) fooString.startsWith(&amp;#34;hello&amp;#34;) -&amp;gt; println(&amp;#34;second block&amp;#34;) else -&amp;gt; println(&amp;#34;else block&amp;#34;) } Yukarıda ki örnek if-else if-else yapısının aynısıdır.
when (i) { 0, 21 -&amp;gt; println(&amp;#34;0 or 21&amp;#34;) in 1..20 -&amp;gt; println(&amp;#34;in the range 1 to 20&amp;#34;) else -&amp;gt; println(&amp;#34;none of the above&amp;#34;) } Yukarıda ki gibi aralıklar tanımlanabilir ve bu aralıklara uyum kontrolü yapılarak ilgili işlemlerin yapılması sağlanılabilir.</description></item><item><title>Kotlin Let Kullanımı</title><link>https://yazilim.aykutasil.com/kotlin-let/</link><pubDate>Tue, 06 Jun 2017 04:33:06 +0300</pubDate><guid>https://yazilim.aykutasil.com/kotlin-let/</guid><description>Kotlin fun &amp;lt;T, R&amp;gt; T.let(f: (T) -&amp;gt; R): R = f(this) let() temel olarak, belirli bir kapsam için bir değişken/kod bloğu oluşturmamızı sağlayan bir kapsamlayıcı işlevdir. Yani let() bir sarmalıyıcı fonksiyondur.
Örneğin:
private var mPhotoUrl: String? = null fun uploadClicked() { if (mPhotoUrl != null) { uploadPhoto(mPhotoUrl!!) } } Yukarıda ki if (mPhotoUrl != null) satırı ile null kontrolü yapılır ve eğer null değilse uploadPhoto(mPhotoUrl!!) kod bloğu çalıştırılır. Bu kodu let() ile çok daha kolay ve anlaşılır hale getirebiliriz.</description></item><item><title>Android ile WebView Etkileşimi</title><link>https://yazilim.aykutasil.com/android-webview-etkilesimi/</link><pubDate>Wed, 11 Jan 2017 19:59:08 +0300</pubDate><guid>https://yazilim.aykutasil.com/android-webview-etkilesimi/</guid><description>Kısa Hikaye : Üstünde çalışmakta olduğum bir projede kredi kartı ile ödeme yapısı kurmam gerekti. Kısaca projenin yapısından bahsedecek olursak
Backend : .Net Client : Android (Java) Ödeme altyapısı : İyzico Client tarafında rest isteğiyle tüm işlemlerimizi backend tarafında yapıyoruz. Ödeme yapımızı da bu doğrultuda geliştirdik.
Problem : 3DS ile ödeme almaya çalıştığımızda malumunuz işin içerisine bankanın bize telefonumuza gelen şifreyi girmemiz için göndermiş olduğu web sayfası vs.</description></item><item><title>RxJava range() Kullanımı</title><link>https://yazilim.aykutasil.com/rxjava-range/</link><pubDate>Wed, 11 Jan 2017 18:52:51 +0300</pubDate><guid>https://yazilim.aykutasil.com/rxjava-range/</guid><description>RxJava range() Kullanımı **Örnek kod:&amp;ndash;
private void range() { Observable.range(3, 5).subscribeOn(Schedulers.io()) .subscribe(success -&amp;gt; { Log.i(TAG, &amp;#34;val: &amp;#34; + success.toString()); }); } Açıklama:
İlk değer 3 kabul edilerek sonraki 5 sayı için teker teker onNext() çağırılır. Yani 3 , 4, 5, 6, 7
Yukarıda ki kodun çıktısı aşağıdaki gibidir.
I/MainActivity: val: 3 I/MainActivity: val: 4 I/MainActivity: val: 5 I/MainActivity: val: 6 I/MainActivity: val: 7 RxJava candır. 😉</description></item><item><title>RxJava scan() Kullanımı</title><link>https://yazilim.aykutasil.com/rxjava-scan/</link><pubDate>Wed, 11 Jan 2017 18:49:21 +0300</pubDate><guid>https://yazilim.aykutasil.com/rxjava-scan/</guid><description>RxJava scan() Kullanımı RxJava da scan() kullanımı iki şekilde olur.
İlk değer ataması yapılarak private void scan() { Observable.just(3, 5, 7, 9) .scan(10,(val1, val2) -&amp;gt; { // Log.i(TAG, &amp;#34;val1: &amp;#34; + val1.toString()); Log.i(TAG, &amp;#34;val2: &amp;#34; + val2.toString()); return val1 + val2; }).subscribeOn(Schedulers.io()) .subscribe(success -&amp;gt; { Log.i(TAG, &amp;#34;Sonuc:&amp;#34; + success.toString()); }); } İlk değer ataması yapılmadan private void scan() { Observable.</description></item><item><title>RxJava reduce() Kullanımı</title><link>https://yazilim.aykutasil.com/rxjava-reduce/</link><pubDate>Wed, 11 Jan 2017 18:42:04 +0300</pubDate><guid>https://yazilim.aykutasil.com/rxjava-reduce/</guid><description>RxJava reduce() Kullanımı reduce() fonskyionu iki şekilde çalışır;
1.Kullanım .reduce(new BiFunction&amp;lt;Integer, Integer, Integer&amp;gt;() { @Override public Integer apply(Integer val1, Integer val2) throws Exception { return null; } }) 2.Kullanım .reduce(10,new BiFunction&amp;lt;Integer, Integer, Integer&amp;gt;() { @Override public Integer apply(Integer val1, Integer val2) throws Exception { return null; } }) 1 ile 2 nin farkı, 2 de görüldüğü üzere fonksiyona başlangıç değeri atanabilmesidir.
Aşağıdaki örneklerde daha net görebilirsiniz.</description></item><item><title>Android Library &amp; Bintray</title><link>https://yazilim.aykutasil.com/android-create-library-upload-bintray/</link><pubDate>Wed, 11 Jan 2017 17:27:29 +0300</pubDate><guid>https://yazilim.aykutasil.com/android-create-library-upload-bintray/</guid><description>Android uygulaması yazarken bazı oluşturmuş olduğunuz yapıları tekrar tekrar yazmak durumunda kalıyorsanız, sizin de artık kendi kütüphanenizi yazmanızın zamanı gelmiş geçiyor demektir. Böyle bir durum söz konusu olmak zorunda değil tabi library oluşturmak için 🙂
Bu yazının konusu Android Library oluşturmak, oluşturmuş olduğumuz bu kütüphaneyi maven ve jcenter repository e deploy etmek olucak.
Ve başlayabiliriz.
İlk olarak Android Studio yu açarak File &amp;gt; New &amp;gt; New Project e tıklayıp yeni bir proje oluşturalım.</description></item><item><title>Android Runtime Permission</title><link>https://yazilim.aykutasil.com/android-runtime-permission/</link><pubDate>Wed, 11 Jan 2017 17:24:52 +0300</pubDate><guid>https://yazilim.aykutasil.com/android-runtime-permission/</guid><description>Yavaş yavaş mevcut android cihazlarının API level düzeyi doğal olarak yükselmekte ve bizlerinde tabi ki buna ayak uydurması gerekmekte.
Bunlardan biri de Android M – Marshmallow (23) ile gelen Runtime Permissions olayı.
Kullanıcı açısından bakıldığında oldukça yararlı birşey gibi duruyor ama tabi ki biz kullanıcılar runtime sırasında çıkan permission dialog daki yazıyı ne kadar okuruz ve buna göre onay veririz meçhul. Aslına bakarsanız çok da okunacağını düşünmüyorum ama olsun yine de güzel.</description></item><item><title>Android Glide ve Palette Kullanımı</title><link>https://yazilim.aykutasil.com/android-glide-ve-palette-kullanimi/</link><pubDate>Wed, 11 Jan 2017 17:11:30 +0300</pubDate><guid>https://yazilim.aykutasil.com/android-glide-ve-palette-kullanimi/</guid><description>Google ın resim işlemleri için geliştirmiş olduğu Glide kütüphanesi Android kaynaklarını, cache mekanizmasını vs. verimli şekilde kullanarak uygulamanıza hız ve kalite kazandırır.
Sizde projenizde resimlerle ilgili herhangi bir işlem yapıyorsanız bu kütüphaneyi incelemenizi tavsiye ediyorum.
Github : https://github.com/bumptech/glide
Gradle : compile ‘com.github.florent37:glidepalette:1.0.6’
Google ın geliştirmiş olduğu Palette kütüphanesi ise, resimlerinizin renkleriyle ilgilenir. Daha farklı işlemler içinde kullanılabilir resim boyutlandırma vs. gibi. Ama renklerle ilgili işlemler için oldukça güzel bir kütüphanedir.</description></item><item><title>Android ViewPager</title><link>https://yazilim.aykutasil.com/android-viewpager/</link><pubDate>Wed, 11 Jan 2017 17:07:51 +0300</pubDate><guid>https://yazilim.aykutasil.com/android-viewpager/</guid><description>Android ViewPager yapısı içerisinde birçok hazır fonksiyonu, animasyonu ve özelleştirilebilir kontrolleri barındırır.
İhtiyaçlarımız doğrultusunda bu yapıyı özelleştirebilir ve ViewPager ın bize sunmuş olduğu rahatlığı kullanabiliriz.</description></item><item><title>Java Collections</title><link>https://yazilim.aykutasil.com/java-collections/</link><pubDate>Wed, 11 Jan 2017 16:10:10 +0300</pubDate><guid>https://yazilim.aykutasil.com/java-collections/</guid><description>Collections.swap Swap kelime anlamı ile takas anlamına gelmektedir. Mevcut dizimiz içerisinde elemanların yerlerini değiştirmeye yarar.
private static final String[] STRINGS = new String[]{ &amp;#34;1&amp;#34;, &amp;#34;2&amp;#34;, &amp;#34;3&amp;#34;, &amp;#34;4&amp;#34;, &amp;#34;5&amp;#34; }; private final List mItems = new ArrayList&amp;lt;&amp;gt;(); public void setArray() { mItems.addAll(Arrays.asList(STRINGS)); } mItems listemizi yazdırdığımızda sonuç şu şekilde olacaktır. // 1,2,3,4,5 private void elemanYerDegistir() { Collections.swap(mItems, 0, 4); } mItems listemizi yazdırdığımızda sonuç şu şekilde olacaktır. // 5,2,3,4,1</description></item><item><title>Android Custom Toolbar Title</title><link>https://yazilim.aykutasil.com/android-custom-toolbar/</link><pubDate>Wed, 11 Jan 2017 16:01:33 +0300</pubDate><guid>https://yazilim.aykutasil.com/android-custom-toolbar/</guid><description>Android Toolbar Android Toolbar bileşeni çok yönlü bir yapıya sahiptir. Android Design Library kullanarak ve AppBarLayout içerisinde tanımlanarak oldukça farklı şekillere bürünebilir.
Genel kullanımı aşağıdaki gibidir.
&amp;lt;?xml version=&amp;#34;1.0&amp;#34; encoding=&amp;#34;utf-8&amp;#34;?&amp;gt; &amp;lt;android.support.design.widget.CoordinatorLayout xmlns:android=&amp;#34;http://schemas.android.com/apk/res/android&amp;#34; xmlns:app=&amp;#34;http://schemas.android.com/apk/res-auto&amp;#34; xmlns:tools=&amp;#34;http://schemas.android.com/tools&amp;#34; android:layout_width=&amp;#34;match_parent&amp;#34; android:layout_height=&amp;#34;match_parent&amp;#34; android:background=&amp;#34;@color/primary_dark&amp;#34; tools:context=&amp;#34;.MainActivity&amp;#34;&amp;gt; &amp;lt;FrameLayout android:id=&amp;#34;@+id/container&amp;#34; android:layout_width=&amp;#34;match_parent&amp;#34; android:layout_height=&amp;#34;match_parent&amp;#34;&amp;gt; &amp;lt;/FrameLayout&amp;gt; &amp;lt;android.support.design.widget.FloatingActionButton android:id=&amp;#34;@+id/fab&amp;#34; android:layout_width=&amp;#34;wrap_content&amp;#34; android:layout_height=&amp;#34;wrap_content&amp;#34; android:layout_gravity=&amp;#34;bottom|end&amp;#34; android:layout_margin=&amp;#34;@dimen/fab_margin&amp;#34; android:src=&amp;#34;@android:drawable/ic_dialog_email&amp;#34; /&amp;gt; &amp;lt;android.support.design.widget.AppBarLayout android:layout_width=&amp;#34;match_parent&amp;#34; android:layout_height=&amp;#34;wrap_content&amp;#34; app:elevation=&amp;#34;0dp&amp;#34;&amp;gt; &amp;lt;android.support.v7.widget.Toolbar android:id=&amp;#34;@+id/toolbar&amp;#34; android:layout_width=&amp;#34;match_parent&amp;#34; android:layout_height=&amp;#34;wrap_content&amp;#34; android:background=&amp;#34;@color/primary_dark&amp;#34; android:minHeight=&amp;#34;?attr/actionBarSize&amp;#34; app:popupTheme=&amp;#34;@style/AppTheme.PopupOverlay&amp;#34;/&amp;gt; &amp;lt;/android.support.design.widget.AppBarLayout&amp;gt; &amp;lt;/android.support.design.widget.CoordinatorLayout&amp;gt; app:elevation=&amp;quot;0dp&amp;quot; // AppBarLayout içerisinde ki bu tanımlama default olarak tanımlanmış gölgeyi kaldırır.</description></item><item><title>Foreground Service ile FusedLocationApi Kullanımı</title><link>https://yazilim.aykutasil.com/foregroundservice-ve-fusedlocationapi-kullanimi/</link><pubDate>Wed, 11 Jan 2017 15:27:59 +0300</pubDate><guid>https://yazilim.aykutasil.com/foregroundservice-ve-fusedlocationapi-kullanimi/</guid><description>Android service yapısı, Android’in temel bileşenlerinden olup genel kullanım amacı yan iş parçacığı oluşturmaktır. Uzun süren işlemler (download vb.) için olmazsa olmaz bileşendir. Android in service bileşenini kendi ihtiyaçlarınız doğrultusunda özelleştirebilir ve uygulamanızı modern bir yapıya kavuşturabilirsiniz.
Burada yapacağımız örnekte kısaca şu aşamaları görücez;
Service i foreground olarak başlatmak Ongoing(devamlı gözüken) notification oluşturmak GoogleApiClient a bağlanmak Location bilgisini notification da göstermek İlk olarak Service imiz kodlarını yazalım. Gerekli açıklamalar kodların arasında mevcuttur.</description></item><item><title>Android GcmNetworkManager Kullanımı</title><link>https://yazilim.aykutasil.com/android-gcmnetworkmanager-kullanimi/</link><pubDate>Wed, 11 Jan 2017 01:43:53 +0300</pubDate><guid>https://yazilim.aykutasil.com/android-gcmnetworkmanager-kullanimi/</guid><description>GcmNetworkManager kullanarak Android de network tabanlı işlemlerinizi olabildiğince kontrollü bir şekide yapabilirsiniz.
GcmNetworkManager ın kullanım alanı daha çok asenkron ve periodic network işlemlerinizi yapılandırmaktır.
Tek sefer çalışacak veya Periodic olarak çalışacak işlemleriniz için 2 tip belirlenmiştir.
OneoffTask PeriodicTask OneoffTask Kullanımı
OneoffTask oneoff = new OneoffTask.Builder() // Uygulamanızı kapatsanız bile tekrar açtığınız da network işleminiz işleme konulur. // Yani isteğinizin kalıcı olup olmamasını bu parametre ile ayarlayabilirsiniz. .</description></item><item><title>Android SMS Receiver</title><link>https://yazilim.aykutasil.com/android-smsreceiver/</link><pubDate>Wed, 11 Jan 2017 01:42:54 +0300</pubDate><guid>https://yazilim.aykutasil.com/android-smsreceiver/</guid><description>Android SMS Receiver Android de gelen sms leri dinlemek ve uygulamanızın akışını gelen sms lere göre şekillendirmek için aşağıdaki yapıyı kullanabilirsiniz.
İlk olarak AndroidManifest.xml dosyanızda receiver tanımlamalısınız. Fakat biz bu receiver ı dinamik olarak tanımlıcaz. Bunu yapmamızın sebebi SMS i dinledikten sonra bu receiver ı silmek ve daha sonra gelen SMS lerin dinlenmesini önlemek.
Siz uygulamınız da sürekli bir SMS dinlemeye ihtiyaç duyarsanız receiver ı AndroidManifest.xml dosyanızda tanımlamalısınız.
Biz burda SMS dinlemesi yaparken önlem amaçlı olarak CPU nun uyumasını önlüyoruz.</description></item><item><title>Android Internet Connection Receiver</title><link>https://yazilim.aykutasil.com/android-internet-connection-receiver/</link><pubDate>Wed, 11 Jan 2017 01:42:36 +0300</pubDate><guid>https://yazilim.aykutasil.com/android-internet-connection-receiver/</guid><description>Uygulamanızın akışını internet kontrolü yaparak yönetmeniz gerekebilir.
Bunun için ilk olarak AndroidManifest.xml dosyasına receiver tanımı yapmalısınız.
&amp;lt;receiver android:name=&amp;#34;.InternetConnectionReceiver&amp;#34;&amp;gt; &amp;lt;intent-filter&amp;gt; &amp;lt;action android:name=&amp;#34;android.net.conn.CONNECTIVITY_CHANGE&amp;#34; /&amp;gt; &amp;lt;/intent-filter&amp;gt; &amp;lt;/receiver&amp;gt; InternetConnectionReceiver
public class InternetConnectionReceiver extends BroadcastReceiver { @Override public void onReceive(Context context, Intent intent) { if (CheckConnection(context)) { } } } Yukarıda tanımlanmış olan receiver, cihazın ağ yapısında herhangi bir değişiklik olduğunda bunu yakalar. Örneğin wireless açıkken kapattığınız da veya kapalıyken açtığınız da bunu yakayabilirsiniz.
CheckConnection</description></item><item><title>Android ActiveAndroid Kullanımı</title><link>https://yazilim.aykutasil.com/activeandroid/</link><pubDate>Wed, 11 Jan 2017 01:00:19 +0300</pubDate><guid>https://yazilim.aykutasil.com/activeandroid/</guid><description>Anroid ile ORM (Object Relational Mapping) kullanarak veritabanı işlemlerinizi oldukça kolay yapabilirsiniz.
ActiveAndroid kütüphanesi ORM kütüphanelerinden biridir.
Kütüphaneyi buradan indirebilirsiniz.
Kullanımı oldukça basittir. Sadece birkaç noktaya özellikle dikkat edilmesi gerekiyor. Bunlardan biri oluşturmuş olduğunuz tabloya yeni alanlar eklediğiniz de tablonuzu güncellemek. Veya herhangi bir sebeple tabloda çeşitli işlemler yapmak.
Aşağıda kısaca Tablo oluşturmaktan ve gerektiğinde Tablo yu nasıl güncelleyeceğimizden bahsedicem.
@Table(name = &amp;#34;Items&amp;#34;) public class ModelSampleItem extends Model { @Column(name = &amp;#34;Name&amp;#34;) public String name; @Column(name = &amp;#34;Surname&amp;#34;) public String surname; @Column(name = &amp;#34;Phone&amp;#34;) public String phoneNumber; @Column(name = &amp;#34;Xyz&amp;#34;) public String xyz; @Column(name = &amp;#34;EMail&amp;#34;) public String email; @Column(name = &amp;#34;TryColumn&amp;#34;) public String tryColumn; @Column(name = &amp;#34;Column3&amp;#34;) public String column3; public ModelSampleItem() { super(); } } Yukarıda ki yapıyı kullanarak istediğiniz Tablo yu oluşturmanız mümkün.</description></item><item><title>Android Key Hashes &amp; SHA1</title><link>https://yazilim.aykutasil.com/android-keyhashes-sha1/</link><pubDate>Tue, 10 Jan 2017 23:56:35 +0300</pubDate><guid>https://yazilim.aykutasil.com/android-keyhashes-sha1/</guid><description>Android Key Hashes &amp;amp; SHA1 Windows komut satırına aşağıdaki komutu yazarak ulaşabilirsiniz.
keytool -exportcert -alias androiddebugkey -keystore %HOMEPATH%\.android\debug.keystore | openssl sha1 -binary | openssl base64 openssl hatası alırsanız https://code.google.com/p/openssl-for-windows/downloads/detail?name=openssl-0.9.8k_X64.zip adresindeki dosyayı indirdikten sonra çıkan dosyadaki bin klasörünü ortam değişkenlerindeki PATH kısmına eklerseniz sorun ortadan kalkacaktır.
Ortam değişkenlerine ulaşmak için : Denetim Masası &amp;gt; Sistem &amp;gt; Gelişmiş Sİstem Ayarları
SHA1 ulaşmak için komut satırına aşağıdaki kodu yazmanız yeterli olacaktır.
your_user_name yerine kendi kullanıcı adınızı yazmayı unutmayın.</description></item><item><title>Android Spinner Text Güncelleme</title><link>https://yazilim.aykutasil.com/android-spinner-dynamic-text/</link><pubDate>Tue, 10 Jan 2017 23:00:03 +0300</pubDate><guid>https://yazilim.aykutasil.com/android-spinner-dynamic-text/</guid><description>Dinamik Olarak Spinner Text Güncelleme Android de Spinner yapısı açılır menü (dropdown) olarak kullanlan kullanışlı bir componenttir.
Farklı ihtiyaçlarınız doğrultusunda Spinner ınızın elemanlarının değerini değiştirmek isteyebilirsiniz.
Örneğin bir ListView iniz var.Ve içerisinde aynı kategoriden ama değişik durumlara sahip itemlar var ve siz bu itemları durumuna göre gruplandırıp sayısını Spinner da göstermek istiyorsunuz. Bunun için aşağıda belirtecek olduğum yapıyı kullanabilirsiniz.
Öncellikle String.xml dosyasına Spinner ımızda göstereceğimiz elemanları tanımlıyoruz.
String.xml
&amp;lt;string name=&amp;#34;pazartesi&amp;#34;&amp;gt;Pazartesi&amp;lt;/string&amp;gt; &amp;lt;string name=&amp;#34;sali&amp;#34;&amp;gt;Salı&amp;lt;/string&amp;gt; &amp;lt;string name=&amp;#34;carsamba&amp;#34;&amp;gt;Çarşamba&amp;lt;/string&amp;gt; &amp;lt;string name=&amp;#34;persembe&amp;#34;&amp;gt;Perşembe&amp;lt;/string&amp;gt; &amp;lt;string name=&amp;#34;cuma&amp;#34;&amp;gt;Cuma&amp;lt;/string&amp;gt; &amp;lt;string name=&amp;#34;cumartesi&amp;#34;&amp;gt;Cumartesi&amp;lt;/string&amp;gt; &amp;lt;string name=&amp;#34;pazar&amp;#34;&amp;gt;Pazar&amp;lt;/string&amp;gt; &amp;lt;string-array name=&amp;#34;array_gonderi_list_haftalik&amp;#34;&amp;gt; &amp;lt;item&amp;gt;@string/pazartesi&amp;lt;/item&amp;gt; &amp;lt;item&amp;gt;@string/sali&amp;lt;/item&amp;gt; &amp;lt;item&amp;gt;@string/carsamba&amp;lt;/item&amp;gt; &amp;lt;item&amp;gt;@string/persembe&amp;lt;/item&amp;gt; &amp;lt;item&amp;gt;@string/cuma&amp;lt;/item&amp;gt; &amp;lt;item&amp;gt;@string/cumartesi&amp;lt;/item&amp;gt; &amp;lt;item&amp;gt;@string/pazar&amp;lt;/item&amp;gt; &amp;lt;/string-array&amp;gt; SpinnerHelper.</description></item></channel></rss>